#难点记录
* 态路由在来回切换时，由于它们都是指向同一组件,组件的生命周期不管用了????
* vue-bus实现原理????
* vuex 
	* actions > Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了
* vue > transition dom渐变动画实现
* arguments
* vue自定义指令
* route跳转出错, "/home"跳转到"/search"却 错误跳转到了"/home/search"
* vue 生命周期
* vue route路由加载守卫
* lazyload
* 跳转route后, 自动聚焦到input 
	* keepalive 后, 组件被复用, mounted函数不一定每次调用. 使用activated钩子

* 动画制作transition
* input > autofocus=true
* form包裹input时,移动端软键盘回车触发submit
* 清楚历史记录时, 弹窗确认
* vue风格指南https://cn.vuejs.org/v2/style-guide/#%E4%B8%BA-v-for-%E8%AE%BE%E7%BD%AE%E9%94%AE%E5%80%BC-%E5%BF%85%E8%A6%81
* vue store 项目结构https://vuex.vuejs.org/zh/guide/structure.html
* 用户权限方案
	* session-cookie所以出现了session-cookie的方案：用户登录后服务器生成一个对应session保存用户状态，将之保存在内存(或数据库)，返回一个sessionId给客户端。浏览器在响应头提取将相关数据保存在cookie中，下次访问就将cookie放到请求头提交给服务器。通过这种方式，服务器就能识别用户的身份，从而判定用户是否有权限执行某些访问。<br>
	但是session机制有一些局限，一个是用户量多的话，对内存开销会很大，相应的的对session计算的开销也变大，而且如果保存在内存，是不利于分布式扩展。另一方面，因为cookie有被截获的风险，所以也容易出现CSRF(跨域请求伪造)。

* 使用阴影强调出模块
* 手机访问电脑上的服务